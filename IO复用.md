I/O 多路复用使得程序能同时监听多个fd，能够提高程序的性能，Linux 下实现 I/O 多路复用的系统调用主要有 select、poll 和 epoll。
“多路”指的是多个网络连接，“复用”指的是复用同一个线程。

# 1. IO复用方式

# 1.1 select
1. 构造一个关于fd的列表，将要监听的fd添加到该列表中。
2. 调用一个阻塞的系统函数（当然也可以设置不阻塞和阻塞时间），使用内核监听该列表中的fd，如果没有的话，就会进入休眠，直到这些描述符中的一个或者多个进行I/O操作时，该函数才返回。
3. 在返回时，它会告诉进程有哪些描述符要进行I/O操作。

* 缺点
1. 每次调用select，都需要把fd集合从用户态拷贝到内核态，然后在内核中遍历fd后又得拷贝到用户态，这个开销在fd很多时会很大。
2. 同时每次调用select都需要在内核遍历传递进来的所有fd，这个开销在fd很多时也很大。
3. select支持的文件描述符数量太小了，默认是1024
4. fds集合不能重用，每次都需要重置。

# 1.2 poll

* 优点
1. poll使用pollfd数组来代替select中的bitmap，数组没有1024的限制，可以一次管理更多的client。
2. 当pollfds数组中有事件发生，相应的revents置位为1（多个事件是|操作），处理完事件对应比特位又置位回零，实现了pollfd数组的重用。

* 缺点
就是select除了3和4的缺点。

# 1.3 epoll

* 执行过程
1. epoll_create创建eventpoll对象（红黑树，双链表）
2. 通过epoll_ctl将注册了事件的fd添加、删除到红黑树
3. epoll_wait调用时，检测链表中是否有数据，有的话直接返回；当有数据的时候，链表会把相应的fd'置位'，但是epoll没有revent标志位，所以会把有数据的文件描述符放到队首。所以只发生了一次拷贝，就是该链表的拷贝。
4. 当有就绪事件时，系统注册的回调函数就会被调用，并将就绪的fd放入到就绪链表中。


事件回调通知机制：
1. 当有网卡上有数据到达了，首先会放到DMA（内存中的一个buffer，网卡可以直接访问这个数据区域
2. 网卡向cpu发起中断，让cpu先处理网卡的事 
3. 中断号在内存中会绑定一个回调，哪个socket中有数据，回调函数就把哪个socket对应的fd放入就绪链表中


### 优点
1. 因为红黑树的机制，当有事件就绪时，epoll_wait只需要检测就绪链表中有没有数据，如果有的话就直接返回
2. 不需要从用户空间到内核空间频繁拷贝文件描述符集合，仅复制一次少数就绪的fd
3. 当有就绪事件发生时采用回调的形式通知用户线程，不需要遍历

### 缺点
1. 只能工作在linux下


### LT（level-triggered，水平触发）模式
类似select，LT会去遍历在epoll事件表中每个文件描述符，来观察是否有我们感兴趣的事件发生，如果有（触发了该文件描述符上的回调函数），epoll_wait就会以非阻塞的方式返回。若该epoll事件没有被处理完（没有返回EWOULDBLOCK），该事件还会被后续的epoll_wait再次触发。

epoll_wait检测到fd有事件发生，则将其通知给应用程序，应用程序可以不立即处理该事件。当下一次调用epoll_wait时，epoll_wait还会再次向应用程序报告此事件，直至被处理。
举个例子：假设委托内核检测读事件 -> 检测fd的读缓冲区 -> 读缓冲区有数据 -> epoll检测到了会给用户通知
用户读数据的不同结果：
1. 用户不读数据，数据一直在缓冲区，epoll会一直通知
2. 用户只读了一部分数据，epoll会通知
3. 缓冲区的数据读完了，才不通知

LT模式是缺省的工作方式，并且同时支持阻塞和非阻塞的socket。在这种做法中，内核告诉你一个fd是否就绪了，然后你可以对这个就绪的 fd 进行 IO 操作。如果你不作任何操作，内核还是会继续通知你的。

### ET（edge-triggered，边沿触发）模式
epoll_wait检测到fd有事件发生，立即返回，并且sleep这一事件的epoll_wait，不管该事件有没有结束。

还是LT的例子：
1. 用户不读数据，数据一致在缓冲区中，epoll下次检测的时候就不通知了
2. 用户只读了一部分数据，epoll下次不通知
3. 缓冲区的数据读完了，下次不通知

ET模式是高速工作方式，只支持非阻塞的socket。在这种模式下，当描述符从未就绪变为就绪时，内核通过epoll告诉你。然后它会假设你知道fd已经就绪，并且不会再为那个fd发送更多的就绪通知，直到你做了某些操作导致那个fd不再为就绪状态了。这也就要求我们在新数据到来的时候最好能够一次性将所有数据取出。而我们也不知道具体有多少数据，所以就需要循环处理，直到缓冲区为空，但是recv是一个阻塞读取，如果没有数据时就会阻塞等待，这时候就需要将描述符的属性设置为非阻塞，才能解决这个问题。

ET 模式在很大程度上减少了 epoll 事件被重复触发的次数，因此效率要比 LT 模式高。

在使用ET模式时，必须要保证该文件描述符是非阻塞的（确保在没有数据可读时，该文件描述符不会一直阻塞）；并且每次调用read和write的时候都必须等到它们返回 EWOULDBLOCK / EAGAIN（确保所有数据都已读完或写完）。

* 一个常见的ET读操作，需要循环一次性读完
```c++
int bytes_read = 0;
while (true) {
    // 从 m_sockfd 端不断读数据到读缓冲区 m_read_buf 中
    bytes_read = recv(m_sockfd, m_read_buf+m_read_idx, READ_BUFFER_SIZE-m_read_idx, 0);
    if (bytes_read == -1) {
        // 读缓存区没了，说明读完了，退出while循环，或者返回一共读取的长度
        // 注意ET是非阻塞的，所以没有EINTR
        if (errno == EAGAIN || errno == EWOULDBLOCK)
            break;  // return m_read_idx; 也行，返回所有
        return false;
    } else if (bytes_read == 0) {
        return m_read_idx;
    }
    m_read_idx += bytes_read;  // 下一次开始读的位置
}
return true;
```

### 两种模式对比
二者的区别在于当你调用epoll_wait的时候内核里面发生了什么：

1. LT模式的优点主要在于其简单且稳定，不容易出现问题，传统的select和poll都是使用这个模式。但是也有缺点，就是因为事件触发过多导致效率降低
2. ET最大的优点就是减少了epoll的触发次数，但是这也带来了巨大的代价，就是要求必须一次性将所有的数据处理完，虽然效率得到了提高，但是代码的复杂程度大大的增加了。Nginx就是默认采用ET模式
3. 有一种场景适合ET模式使用，如果我们需要接受一条数据，但是这条数据因为某种问题导致其发送不完整，需要分批发送。所以此时的缓冲区中数据只有部分，如果此时将其取出，则会增加维护数据的开销，正确的做法应该是等待后续数据到达后将其补全，再一次性取出。但是如果此时使用的是LT模式，就会因为缓冲区不为空而一直触发事件，所以这种情况下使用ET会比较好。（拆包粘包问题）




## select/poll/epoll的区别联系
* fd数量
    * select通过线性表描述fd集合，fd有上限，一般是1024，但可以修改源码，重新编译内核，不推荐
    * poll是链表描述，突破了fd上限，所以最大值就是最大可以打开文件的数目，65535
    * epoll同理，为最大可以打开文件的数目65535，可以通过命令ulimit -n number修改，仅对当前终端有效
* fd数据拷贝
    * select和poll需要用户和内核之间的拷贝
    * epoll_wait向用户进程返回复制过的就绪链表，将其放到用户分配的epollevent数组中，并将实际复制的个数作为返回值。
* 判断是否有fd的方式
    * select和poll是线性遍历，查看各个fd上注册的事件是否就绪
    * epoll当有活动时，会自动触发回调函数通知epoll实例fd，然后内核将这些就绪的文件描述符放到之前提到的ready list中等待epoll_wait调用后被处理。
* 工作模式
    * select和poll都只能工作在相对低效的LT模式下
    * epoll则可以工作在ET高效模式，并且epoll还支持EPOLLONESHOT事件，该事件能进一步减少可读、可写和异常事件被触发的次数。 
* 应用场景
    * 当监测的fd数目较小（少于1024个fd监听），且各个fd都比较活跃，建议使用select或者poll
    * 当监测的fd数目非常大，成千上万，且单位时间只有其中的一部分fd处于就绪状态，这个时候使用epoll能够明显提升性能
* 数据结构
    * bitmap
    * 链表
    * 红黑树和双向链表

### 总结
IO复用本质上还是阻塞，如果多个fd同时事件触发，只能依次处理。并发还得靠多线程/进程

综上，当监测的fd数量较小，且各个fd都很活跃的情况下，建议使用select和poll；当监听的fd数量较多，且单位时间仅部分fd活跃的情况下，使用epoll会明显提升性能。



