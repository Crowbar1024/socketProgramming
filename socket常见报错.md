# EINTR（Interrupted system call）
### 前置知识：慢系统调用
部分调用有可能永远无法返回，比如多数网络支持函数。举几个例子：
* 读写‘慢’设备（包括pipe，终端设备，网络连接等）。读时，数据不存在，需要等待；写时，缓冲区满或其他原因，需要等待。
但读写磁盘文件一般不会阻塞。这个原因很复杂：传统的硬盘概念没有提供轮询传输状态的接口。不像网络设备设计之初就考虑到延迟的大变动范围和不确定性，于是设计上就提供了带状态检测的异步操作方式。而硬盘作为一个自始至终都是“写不完就不行”的设备，异步操作接口是在最近几年才真正做到硬件接口里的。因为一直以来硬盘都是唯一可靠的持久本地存储，需要写入的数据如果不能写入意味着灾难性的后果。所以即便是现代操作系统，也并不轻易允许磁盘IO的纯异步化。
所以常规的non-blocking适用于网络io但是对硬盘io不起作用。
* 若没有客户连接到服务器上，那么服务器的accept调用就没有返回的保证。
* epoll_wait设置阻塞，这样从内核读取eventpoll事件表需要事件触发才能返回。

综上，如果一个进程阻塞于某个慢系统调用，此时收到一个信号，系统会中断阻塞，执行信号处理函数。从处理函数返回后，可能返回一个EINTR错误。（注意：在非阻塞模式下，不会出现这种错误。）

### 处理方式
* 人为重启被中断的系统调用
accept、read、write、select、和open之类的函数来说，是可以进行重启的。（不过对于socket编程中的connect函数我们是不能重启的，若connect函数返回一个EINTR错误的时候，我们不能再次调用它，否则将立即返回一个错误。针对connect不能重启的处理方法是，必须调用select来等待连接完成。）
* 安装信号时设置 SA_RESTART属性（该方法对有的系统调用无效）
```c++
struct sigaction action;  
action.sa_handler = handler_func;  
sigemptyset(&action.sa_mask);  
action.sa_flags = 0;  
/* 设置SA_RESTART属性 */  
action.sa_flags |= SA_RESTART;  
sigaction(SIGALRM, &action, NULL);  
```

*   忽略信号（让系统不产生信号中断）

```c++
struct sigaction action;  
action.sa_handler = SIG_IGN;  
sigemptyset(&action.sa_mask);
sigaction(SIGALRM, &action, NULL);  
```

### 我遇到的情况

1 一个使用多进程处理客户端连接的服务端程序，父进程注册了SIGCHILD信号的捕捉处理（轮询回收子进程资源）。父进程负责接受新的客户端连接，然后fork一个子进程负责对新的客户端进行通信（子进程会继承信号处理，但子进程是不会收到SIGCHILD信号），客户端关闭就退出子进程。

父进程在accept处阻塞，同时捕获SIGCHILD信号且相应信号处理函数返回时，该系统调用可能返回一个EINTR错误。

处理方法：将这次读到的长度赋值0，再次循环

2 epoll\_wait设置为阻塞，建立一个进程间通信的管道，将管道读端注册到epoll实例中 ，注册SIGALARM信号，信号处理函数中把信号传输到管道写端，主函数开始5s的计时，时间一到，epoll就会捕捉到信号事件，检查信号是否为SIGALARM 。如果是的话，当处理完当前所有epoll事件后，开始对定时器链表做清理工作。

显然epoll\_wait返回后，errno有可能为EINTR。

3 单纯的读写操作

处理方法：将本次读到的长度置零，继续读的循环

## EAGAIN

```c++
#define EWOULDBLOCK EAGAIN // 所以我一般只处理一个
```

从字面上来看，是提示再试一次。这个错误经常出现在当应用程序对文件进行一些非阻塞操作的时候。
### 场景和处理方法
1. 以fcntl函数将O_NONBLOCK的标志赋予fd，用while连续做读操作而没有数据可读，socket接口函数会返回一个EAGAIN，提示你的应用程序现在没有数据可读请稍后再试。

* 一般理解为读完了，返回整个循环读取的长度（注意是这一次读完，对方并没有断开连接，断开连接socket读的接口会返回）；或者直接break；

2. 同1，但这次是循环往fd中写数据，EAGAIN 在写时出现说明TCP的发送缓冲被填满。
* 将本次读的长度置零，continue继续写。或者直接返回。
* 如果应用程序有EPOLLONESHOT的需求，由于此只会触发一次的属性，每次事件触发后需要重置socket上的各种事件触发机制，这次除了EPOLLONESHOT和EPOLLRDHUP，还需要注册EPOLLOUT。说明等待下一轮EPOLLOUT事件，并直接返回。虽然在此期间， 服务器无法立即接收到同一客户的下一个请求，但可以保证连接的完整性。

3. 当一个系统调用(比如fork)因为没有足够的资源(比如虚拟内存)而执行失败，返回EAGAIN提示其再调用一次(也许下次就能成功)。

4
